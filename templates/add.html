{% extends "base.html" %}

{% block title %}Home{% endblock %}

{% block content %}

    <style>
      /* small layout nicety */
      .page-container { padding: 2rem; max-width: 720px; margin: 0 auto; }
      .spinner-inline { width: 1rem; height: 1rem; vertical-align: text-bottom; margin-left: .5rem; }

      /* Shiny option styles */
      .shiny-options { display: flex; gap: 1.25rem; align-items: center; margin-top: .5rem; }
      .shiny-option { display: inline-flex; align-items: center; gap: .5rem; }

      /* visually hide the native radio but keep it accessible */
      .shiny-option input[type="radio"] {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
        border: 0;
      }

      /* the custom box that appears next to the label text */
      .option-box {
        display: inline-block;
        width: 1.25rem;
        height: 1.25rem;
        border: 2px solid #cbd5e1; /* soft gray */
        border-radius: 6px;
        background: white;
        box-sizing: border-box;
        position: relative;
        transition: border-color .12s ease, background-color .12s ease, box-shadow .12s ease;
      }

      /* subtle focus ring for keyboard users */
      .shiny-option input[type="radio"]:focus + .option-box {
        box-shadow: 0 0 0 4px rgba(59,130,246,0.12); /* soft blue halo */
      }

      /* checked state: blue border and filled check */
      .shiny-option input[type="radio"]:checked + .option-box {
        border-color: #3b82f6; /* blue (not overpowering) */
        background-color: #3b82f6;
      }

      /* checkmark (white) shown when checked */
      .option-box::after {
        content: "";
        position: absolute;
        left: 6px;
        top: 2px;
        width: 6px;
        height: 10px;
        border: solid white;
        border-width: 0 2px 2px 0;
        transform: rotate(45deg);
        opacity: 0;
        transition: opacity .12s ease;
      }

      .shiny-option input[type="radio"]:checked + .option-box::after {
        opacity: 1;
      }

      /* small spacing for the "Yes"/"No" text */
      .option-text { font-size: 0.95rem; color: #111827; }
    </style>
  
 
    <h1>Pokemon item creator</h1>

    <form id="itemForm" method="post" novalidate>
      <div class="mb-3">
        <label class="form-label">Name</label>
        <div class="input-group">
          <input id="name" name="name" type="text" class="form-control" placeholder="Name" required autocomplete="off">
          <span id="nameSpinner" class="input-group-text bg-white border-start-0" style="display:none;">
            <div class="spinner-border spinner-border-sm spinner-inline" role="status" aria-hidden="true"></div>
          </span>
        </div>
      </div>

      <!-- NEW: Shiny field (two selectable boxes: Yes / No) -->
      <div class="mb-3">
        <label class="form-label">Shiny</label>
        <div class="shiny-options" role="radiogroup" aria-label="Shiny">
          <div class="shiny-option">
            <span class="option-text">Yes</span>
            <input type="radio" id="shinyYes" name="shiny" value="true" aria-checked="false">
            <label for="shinyYes" class="option-box" title="Yes"></label>
          </div>

          <div class="shiny-option">
            <span class="option-text">No</span>
            <input type="radio" id="shinyNo" name="shiny" value="false" checked aria-checked="true">
            <label for="shinyNo" class="option-box" title="No"></label>
          </div>
        </div>
      </div>

      <div class="mb-3">
        <label class="form-label">Type1</label>
        <input id="type1" name="type1" type="text" class="form-control" placeholder="Primary Type" required>
      </div>

      <div class="mb-3">
        <label class="form-label">Type2</label>
        <input id="type2" name="type2" type="text" class="form-control" placeholder="Secondary Type (optional)">
      </div>

      <div class="mb-3">
        <label class="form-label">Nickname</label>
        <input id="nickname" name="nickname" type="text" class="form-control" placeholder="Nickname (optional)">
      </div>

      <div class="mb-3">
        <button id="submitBtn" type="submit" class="btn btn-primary" disabled>Create Item</button>
      </div>

      <div id="formMessages" aria-live="polite"></div>
    </form>

    <script>
(function () {
  const nameInput = document.getElementById('name');
  const type1Input = document.getElementById('type1');
  const type2Input = document.getElementById('type2');
  const submitBtn = document.getElementById('submitBtn');
  const messages = document.getElementById('formMessages');
  const nameSpinner = document.getElementById('nameSpinner');

  // --- NEW: suggestions container and cached names ---
  const suggestionsBox = document.createElement('div');
  suggestionsBox.id = 'nameSuggestions';
  suggestionsBox.style.position = 'absolute';
  suggestionsBox.style.zIndex = '1000';
  suggestionsBox.style.background = '#fff';
  suggestionsBox.style.border = '1px solid rgba(0,0,0,0.15)';
  // remove top border and flatten top corners so there is no visible gap
  suggestionsBox.style.borderTop = '0';
  suggestionsBox.style.borderRadius = '0 0 4px 4px';
  suggestionsBox.style.boxShadow = '0 4px 8px rgba(0,0,0,0.06)';
  suggestionsBox.style.maxHeight = '240px';
  suggestionsBox.style.overflow = 'auto';
  suggestionsBox.style.display = 'none';
  suggestionsBox.style.boxSizing = 'border-box';
  suggestionsBox.setAttribute('role', 'listbox');
  suggestionsBox.setAttribute('aria-label', 'Pokémon suggestions');
  // append to body so absolute positioning uses viewport coordinates reliably
  document.body.appendChild(suggestionsBox);

  // helper to position suggestions exactly under the input with no gap
  function positionSuggestions() {
    const rect = nameInput.getBoundingClientRect();
    suggestionsBox.style.width = rect.width + 'px';
    suggestionsBox.style.left = rect.left + window.scrollX + 'px';
    // place top exactly at the input bottom; borderTop is removed so no visible gap
    suggestionsBox.style.top = rect.bottom + window.scrollY + 'px';
  }
  // state
  let pokemonExists = false;
  let checking = false;
  let debounceTimer = null;
  let cachedNames = null;
  let loadingNames = false;
  const DEBOUNCE_MS = 1000; // wait 1 second after typing stops

  // helper: show message(s)
  function setMessage(text, kind = 'danger') {
    if (!text) {
      messages.innerHTML = '';
      return;
    }
    messages.innerHTML = `<div class="alert alert-${kind} py-2">${escapeHtml(text)}</div>`;
  }

  // escape to avoid injection if user types weird characters
  function escapeHtml(str) {
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  // show/hide spinner
  function showSpinner(show) {
    nameSpinner.style.display = show ? '' : 'none';
  }

  // validate required fields (except type2)
  function requiredFieldsFilled() {
    return nameInput.value.trim() !== '' && type1Input.value.trim() !== '';
  }

  // update submit button enabled/disabled based on state
  function updateSubmitState() {
    // disable while checking
    if (checking) {
      submitBtn.disabled = true;
      return;
    }

    // required fields must be filled and pokemon must exist
    if (!requiredFieldsFilled()) {
      submitBtn.disabled = true;
      // show which fields are missing
      const missing = [];
      if (nameInput.value.trim() === '') missing.push('Name');
      if (type1Input.value.trim() === '') missing.push('Primary Type');
  
      setMessage('Please fill out required fields: ' + missing.join(', '), 'danger');
      return;
    }

    // if name is filled but we haven't confirmed existence yet
    if (!pokemonExists) {
      submitBtn.disabled = true;
      setMessage('Pokemon not found. Check the name or wait for the verification spinner to finish.', 'danger');
      return;
    }

    // all good
    submitBtn.disabled = false;
    setMessage('All good — you can submit the form.', 'success');
  }

  // check pokemon existence via PokeAPI and autofill types when found
  async function checkPokemon(name) {
    const normalized = name.trim().toLowerCase();
    if (!normalized) {
      pokemonExists = false;
      checking = false;
      showSpinner(false);
      // make types editable again
      type1Input.readOnly = false;
      type2Input.readOnly = false;
      updateSubmitState();
      return;
    }

    checking = true;
    pokemonExists = false;
    showSpinner(true);
    setMessage('Checking Pokémon name...', 'info');

    try {
      const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${encodeURIComponent(normalized)}`, { method: 'GET' });

      if (res.ok) {
        // found — parse types and autofill
        const data = await res.json();
        const types = (data.types || [])
          .slice() // copy
          .sort((a, b) => a.slot - b.slot)
          .map(t => t.type && t.type.name ? t.type.name : '');

        // set values (slot 1 -> type1, slot 2 -> type2 if present)
        type1Input.value = types[0] || '';
        type2Input.value = types[1] || '';

        // lock the type fields so user cannot edit them but they still submit
        type1Input.readOnly = true;
        type2Input.readOnly = true;
        type1Input.setAttribute('aria-readonly', 'true');
        type2Input.setAttribute('aria-readonly', 'true');

        pokemonExists = true;
        checking = false;
        showSpinner(false);
        updateSubmitState();
      } else if (res.status === 404) {
        // not found — allow manual editing of types
        pokemonExists = false;
        checking = false;
        showSpinner(false);
        type1Input.readOnly = false;
        type2Input.readOnly = false;
        type1Input.removeAttribute('aria-readonly');
        type2Input.removeAttribute('aria-readonly');
        updateSubmitState();
      } else {
        // other server error
        pokemonExists = false;
        checking = false;
        showSpinner(false);
        type1Input.readOnly = false;
        type2Input.readOnly = false;
        setMessage('Error checking Pokémon name (server returned ' + res.status + ').', 'danger');
        updateSubmitState();
      }
    } catch (err) {
      // network error
      pokemonExists = false;
      checking = false;
      showSpinner(false);
      type1Input.readOnly = false;
      type2Input.readOnly = false;
      setMessage('Network error while checking Pokémon name. Please check your connection and try again.', 'danger');
      updateSubmitState();
    }
  }

  // --- NEW: load all pokemon names once and cache them ---
  async function loadAllPokemonNames() {
    if (cachedNames || loadingNames) return;
    loadingNames = true;
    try {
      // fetch a large list once; PokeAPI supports large limit
      const res = await fetch('https://pokeapi.co/api/v2/pokemon?limit=100000');
      if (!res.ok) {
        loadingNames = false;
        return;
      }
      const json = await res.json();
      cachedNames = (json.results || []).map(r => String(r.name).toLowerCase());
    } catch (e) {
      // ignore failures; suggestions will simply not appear
      cachedNames = null;
    } finally {
      loadingNames = false;
    }
  }

  // --- NEW: show suggestions filtered from cachedNames ---
  function showSuggestionsFor(value) {
    const q = String(value || '').trim().toLowerCase();
    if (!q || !cachedNames || cachedNames.length === 0) {
      suggestionsBox.style.display = 'none';
      suggestionsBox.innerHTML = '';
      return;
    }

    // filter for names that start with the query (fast, local)
    const matches = [];
    // small optimization: stop after 8 matches
    for (let i = 0, len = cachedNames.length; i < len && matches.length < 8; i++) {
      const n = cachedNames[i];
      if (n.startsWith(q)) matches.push(n);
    }

    if (matches.length === 0) {
      suggestionsBox.style.display = 'none';
      suggestionsBox.innerHTML = '';
      return;
    }

    // build suggestion items
    suggestionsBox.innerHTML = '';
    matches.forEach((name) => {
      const item = document.createElement('div');
      item.textContent = name;
      item.setAttribute('role', 'option');
      item.style.padding = '6px 10px';
      item.style.cursor = 'pointer';
      item.style.whiteSpace = 'nowrap';
      item.style.textTransform = 'none';
      item.addEventListener('mousedown', (ev) => {
        // use mousedown to avoid blur before click
        ev.preventDefault();
        nameInput.value = name;
        // hide suggestions immediately
        suggestionsBox.style.display = 'none';
        suggestionsBox.innerHTML = '';
        // when user selects, proceed to check immediately (bypass debounce)
        if (debounceTimer) {
          clearTimeout(debounceTimer);
          debounceTimer = null;
        }
        // trigger the same behavior as input: allow types to be locked/unlocked
        pokemonExists = false;
        type1Input.readOnly = false;
        type2Input.readOnly = false;
        type1Input.removeAttribute('aria-readonly');
        type2Input.removeAttribute('aria-readonly');
        // run check
        checkPokemon(name);
      });
      item.addEventListener('mouseover', () => {
        item.style.background = '#f5f5f5';
      });
      item.addEventListener('mouseout', () => {
        item.style.background = '';
      });
      suggestionsBox.appendChild(item);
    });

    // position suggestions box under the input (recompute width/position in case of layout changes)
    const rect = nameInput.getBoundingClientRect();
    suggestionsBox.style.minWidth = rect.width + 'px';
    suggestionsBox.style.left = rect.left + window.scrollX + 'px';
    suggestionsBox.style.top = rect.bottom + window.scrollY + 'px';
    suggestionsBox.style.display = '';
  }

  // debounce wrapper
  function scheduleCheck() {
    // clear previous timer
    if (debounceTimer) clearTimeout(debounceTimer);

    // if name empty, cancel check immediately
    if (nameInput.value.trim() === '') {
      pokemonExists = false;
      checking = false;
      showSpinner(false);
      // keep types editable when name is empty
      type1Input.readOnly = false;
      type2Input.readOnly = false;
      updateSubmitState();
      // hide suggestions
      suggestionsBox.style.display = 'none';
      return;
    }

    // set checking state and show spinner immediately so user sees feedback
    checking = true;
    showSpinner(true);
    setMessage('Waiting to check Pokémon name...', 'info');
    updateSubmitState();

    // schedule both suggestion display and the API existence check after debounce
    debounceTimer = setTimeout(() => {
      // ensure names are loaded (fire-and-forget)
      loadAllPokemonNames().then(() => {
        showSuggestionsFor(nameInput.value);
      }).catch(() => {
        // ignore
      });

      checkPokemon(nameInput.value);
      debounceTimer = null;
    }, DEBOUNCE_MS);
  }

  // attach events
  nameInput.addEventListener('input', () => {
    // whenever name changes, we must re-validate
    pokemonExists = false;

    // when user edits the name, allow manual editing of types until a match is found
    type1Input.readOnly = false;
    type2Input.readOnly = false;
    type1Input.removeAttribute('aria-readonly');
    type2Input.removeAttribute('aria-readonly');

    // start loading names early (non-blocking)
    loadAllPokemonNames();

    scheduleCheck();
  });

  // hide suggestions when input loses focus, but allow clicks on suggestions (use timeout)
  nameInput.addEventListener('blur', () => {
    setTimeout(() => {
      suggestionsBox.style.display = 'none';
      suggestionsBox.innerHTML = '';
    }, 150);
  });

  // reposition suggestions on window resize/scroll to keep it aligned
  window.addEventListener('resize', () => {
    if (suggestionsBox.style.display !== 'none') {
      const rect = nameInput.getBoundingClientRect();
      suggestionsBox.style.left = rect.left + window.scrollX + 'px';
      suggestionsBox.style.top = rect.bottom + window.scrollY + 'px';
      suggestionsBox.style.minWidth = rect.width + 'px';
    }
  });
  window.addEventListener('scroll', () => {
    if (suggestionsBox.style.display !== 'none') {
      const rect = nameInput.getBoundingClientRect();
      suggestionsBox.style.left = rect.left + window.scrollX + 'px';
      suggestionsBox.style.top = rect.bottom + window.scrollY + 'px';
    }
  }, true);

  // other required fields should trigger validation on input
  [type1Input].forEach(el => {
  el.addEventListener('input', () => {
    updateSubmitState();
  });
});

  // initial validation on load
  updateSubmitState();

  // prevent form submission if disabled (extra safety)
  document.getElementById('itemForm').addEventListener('submit', function (e) {
    if (submitBtn.disabled) {
      e.preventDefault();
      setMessage('Cannot submit: fix the issues above before submitting.', 'danger');
      return;
    }
    // otherwise allow normal submit (or you can handle via AJAX here)
  });

  // accessibility: hide spinner from screen readers when not visible
  const observer = new MutationObserver(() => {
    nameSpinner.setAttribute('aria-hidden', nameSpinner.style.display === 'none' ? 'true' : 'false');
  });
  observer.observe(nameSpinner, { attributes: true, attributeFilter: ['style'] });
})();
</script>
{% endblock %}