{% extends "base.html" %}

{% block title %}Home{% endblock %}

{% block content %}

    <style>
      /* small layout nicety */
      .page-container { padding: 2rem; max-width: 720px; margin: 0 auto; }
      .spinner-inline { width: 1rem; height: 1rem; vertical-align: text-bottom; margin-left: .5rem; }

      /* Shiny option styles */
      .shiny-options { display: flex; gap: 1.25rem; align-items: center; margin-top: .5rem; }
      .shiny-option { display: inline-flex; align-items: center; gap: .5rem; }

      /* visually hide the native radio but keep it accessible */
      .shiny-option input[type="radio"] {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
        border: 0;
      }

      /* the custom box that appears next to the label text */
      .option-box {
        display: inline-block;
        width: 1.25rem;
        height: 1.25rem;
        border: 2px solid #cbd5e1; /* soft gray */
        border-radius: 6px;
        background: white;
        box-sizing: border-box;
        position: relative;
        transition: border-color .12s ease, background-color .12s ease, box-shadow .12s ease;
      }

      /* subtle focus ring for keyboard users */
      .shiny-option input[type="radio"]:focus + .option-box {
        box-shadow: 0 0 0 4px rgba(59,130,246,0.12); /* soft blue halo */
      }

      /* checked state: blue border and filled check */
      .shiny-option input[type="radio"]:checked + .option-box {
        border-color: #3b82f6; /* blue (not overpowering) */
        background-color: #3b82f6;
      }

      /* checkmark (white) shown when checked */
      .option-box::after {
        content: "";
        position: absolute;
        left: 6px;
        top: 2px;
        width: 6px;
        height: 10px;
        border: solid white;
        border-width: 0 2px 2px 0;
        transform: rotate(45deg);
        opacity: 0;
        transition: opacity .12s ease;
      }

      .shiny-option input[type="radio"]:checked + .option-box::after {
        opacity: 1;
      }

      /* small spacing for the "Yes"/"No" text */
      .option-text { font-size: 0.95rem; color: #111827; }
    </style>
  </head>
  <body>
    <h1>Pokemon item creator</h1>

    <form id="itemForm" method="post" novalidate>
      <div class="mb-3">
        <label class="form-label">Name</label>
        <div class="input-group">
          <input id="name" name="name" type="text" class="form-control" placeholder="Name" required autocomplete="off">
          <span id="nameSpinner" class="input-group-text bg-white border-start-0" style="display:none;">
            <div class="spinner-border spinner-border-sm spinner-inline" role="status" aria-hidden="true"></div>
          </span>
        </div>
      </div>

      <!-- NEW: Shiny field (two selectable boxes: Yes / No) -->
      <div class="mb-3">
        <label class="form-label">Shiny</label>
        <div class="shiny-options" role="radiogroup" aria-label="Shiny">
          <div class="shiny-option">
            <span class="option-text">Yes</span>
            <input type="radio" id="shinyYes" name="shiny" value="true" aria-checked="false">
            <label for="shinyYes" class="option-box" title="Yes"></label>
          </div>

          <div class="shiny-option">
            <span class="option-text">No</span>
            <input type="radio" id="shinyNo" name="shiny" value="false" checked aria-checked="true">
            <label for="shinyNo" class="option-box" title="No"></label>
          </div>
        </div>
      </div>

      <div class="mb-3">
        <label class="form-label">Type1</label>
        <input id="type1" name="type1" type="text" class="form-control" placeholder="Type1" required>
      </div>

      <div class="mb-3">
        <label class="form-label">Type2</label>
        <input id="type2" name="type2" type="text" class="form-control" placeholder="Type2 (optional)">
      </div>

      <div class="mb-3">
        <label class="form-label">Gen</label>
        <input id="gen" name="gen" type="number" class="form-control" placeholder="Gen" required min="1">
      </div>

      <div class="mb-3">
        <button id="submitBtn" type="submit" class="btn btn-primary" disabled>Create Item</button>
      </div>

      <div id="formMessages" aria-live="polite"></div>
    </form>

    <script>
(function () {
  const nameInput = document.getElementById('name');
  const type1Input = document.getElementById('type1');
  const type2Input = document.getElementById('type2');
  const genInput = document.getElementById('gen');
  const submitBtn = document.getElementById('submitBtn');
  const messages = document.getElementById('formMessages');
  const nameSpinner = document.getElementById('nameSpinner');

  // state
  let pokemonExists = false;
  let checking = false;
  let debounceTimer = null;
  const DEBOUNCE_MS = 1000; // wait 1 second after typing stops

  // helper: show message(s)
  function setMessage(text, kind = 'danger') {
    if (!text) {
      messages.innerHTML = '';
      return;
    }
    messages.innerHTML = `<div class="alert alert-${kind} py-2">${escapeHtml(text)}</div>`;
  }

  // escape to avoid injection if user types weird characters
  function escapeHtml(str) {
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  // show/hide spinner
  function showSpinner(show) {
    nameSpinner.style.display = show ? '' : 'none';
  }

  // validate required fields (except type2)
  function requiredFieldsFilled() {
    return nameInput.value.trim() !== '' && type1Input.value.trim() !== '' && genInput.value.trim() !== '';
  }

  // update submit button enabled/disabled based on state
  function updateSubmitState() {
    // disable while checking
    if (checking) {
      submitBtn.disabled = true;
      return;
    }

    // required fields must be filled and pokemon must exist
    if (!requiredFieldsFilled()) {
      submitBtn.disabled = true;
      // show which fields are missing
      const missing = [];
      if (nameInput.value.trim() === '') missing.push('Name');
      if (type1Input.value.trim() === '') missing.push('Type1');
      if (genInput.value.trim() === '') missing.push('Gen');
      setMessage('Please fill out required fields: ' + missing.join(', '), 'danger');
      return;
    }

    // if name is filled but we haven't confirmed existence yet
    if (!pokemonExists) {
      submitBtn.disabled = true;
      setMessage('Pokemon not found. Check the name or wait for the verification spinner to finish.', 'danger');
      return;
    }

    // all good
    submitBtn.disabled = false;
    setMessage('All good — you can submit the form.', 'success');
  }

  // check pokemon existence via PokeAPI and autofill types when found
  async function checkPokemon(name) {
    const normalized = name.trim().toLowerCase();
    if (!normalized) {
      pokemonExists = false;
      checking = false;
      showSpinner(false);
      // make types editable again
      type1Input.readOnly = false;
      type2Input.readOnly = false;
      updateSubmitState();
      return;
    }

    checking = true;
    pokemonExists = false;
    showSpinner(true);
    setMessage('Checking Pokémon name...', 'info');

    try {
      const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${encodeURIComponent(normalized)}`, { method: 'GET' });

      if (res.ok) {
        // found — parse types and autofill
        const data = await res.json();
        const types = (data.types || [])
          .slice() // copy
          .sort((a, b) => a.slot - b.slot)
          .map(t => t.type && t.type.name ? t.type.name : '');

        // set values (slot 1 -> type1, slot 2 -> type2 if present)
        type1Input.value = types[0] || '';
        type2Input.value = types[1] || '';

        // lock the type fields so user cannot edit them but they still submit
        type1Input.readOnly = true;
        type2Input.readOnly = true;
        type1Input.setAttribute('aria-readonly', 'true');
        type2Input.setAttribute('aria-readonly', 'true');

        pokemonExists = true;
        checking = false;
        showSpinner(false);
        updateSubmitState();
      } else if (res.status === 404) {
        // not found — allow manual editing of types
        pokemonExists = false;
        checking = false;
        showSpinner(false);
        type1Input.readOnly = false;
        type2Input.readOnly = false;
        type1Input.removeAttribute('aria-readonly');
        type2Input.removeAttribute('aria-readonly');
        updateSubmitState();
      } else {
        // other server error
        pokemonExists = false;
        checking = false;
        showSpinner(false);
        type1Input.readOnly = false;
        type2Input.readOnly = false;
        setMessage('Error checking Pokémon name (server returned ' + res.status + ').', 'danger');
        updateSubmitState();
      }
    } catch (err) {
      // network error
      pokemonExists = false;
      checking = false;
      showSpinner(false);
      type1Input.readOnly = false;
      type2Input.readOnly = false;
      setMessage('Network error while checking Pokémon name. Please check your connection and try again.', 'danger');
      updateSubmitState();
    }
  }

  // debounce wrapper
  function scheduleCheck() {
    // clear previous timer
    if (debounceTimer) clearTimeout(debounceTimer);

    // if name empty, cancel check immediately
    if (nameInput.value.trim() === '') {
      pokemonExists = false;
      checking = false;
      showSpinner(false);
      // keep types editable when name is empty
      type1Input.readOnly = false;
      type2Input.readOnly = false;
      updateSubmitState();
      return;
    }

    // set checking state and show spinner immediately so user sees feedback
    checking = true;
    showSpinner(true);
    setMessage('Waiting to check Pokémon name...', 'info');
    updateSubmitState();

    debounceTimer = setTimeout(() => {
      checkPokemon(nameInput.value);
      debounceTimer = null;
    }, DEBOUNCE_MS);
  }

  // attach events
  nameInput.addEventListener('input', () => {
    // whenever name changes, we must re-validate
    pokemonExists = false;

    // when user edits the name, allow manual editing of types until a match is found
    type1Input.readOnly = false;
    type2Input.readOnly = false;
    type1Input.removeAttribute('aria-readonly');
    type2Input.removeAttribute('aria-readonly');

    scheduleCheck();
  });

  // other required fields should trigger validation on input
  [type1Input, genInput].forEach(el => {
    el.addEventListener('input', () => {
      updateSubmitState();
    });
  });

  // initial validation on load
  updateSubmitState();

  // prevent form submission if disabled (extra safety)
  document.getElementById('itemForm').addEventListener('submit', function (e) {
    if (submitBtn.disabled) {
      e.preventDefault();
      setMessage('Cannot submit: fix the issues above before submitting.', 'danger');
      return;
    }
    // otherwise allow normal submit (or you can handle via AJAX here)
  });

  // accessibility: hide spinner from screen readers when not visible
  const observer = new MutationObserver(() => {
    nameSpinner.setAttribute('aria-hidden', nameSpinner.style.display === 'none' ? 'true' : 'false');
  });
  observer.observe(nameSpinner, { attributes: true, attributeFilter: ['style'] });
})();
</script>
  </body>
</html>
{% endblock %}